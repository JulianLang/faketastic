import { quantity } from '../../src/attached-fns';
import { createBuildable } from '../../src/buildable';
import { build, MutationFn } from '../../src/builder';
import { Type } from '../../src/constants';
import { use } from '../../src/property-fns';
import { AnyFn, AnyObject, Func } from '../../src/types';

type HasTypeSymbol = Record<typeof Type, string>;
type TypeCheckFn = Func<[any, string?], boolean>;
type FnFactory = Func<[AnyFn, any?], Partial<HasTypeSymbol>>;

export const TypeCheckFnSpecs = {
  returnTrueForTypeMatches: (fn: TypeCheckFn, expectedType: string) =>
    it('should return true if the type matches', () => {
      // arrange
      const value = { [Type]: expectedType };

      // act
      const result = fn(value);

      // assert
      expect(result).toBe(true);
    }),
  returnFalseForNonMatches: (fn: TypeCheckFn) =>
    it('should return false if the type does not match', () => {
      // arrange
      const value = { [Type]: 'other-type' };

      // act
      const result = fn(value);

      // assert
      expect(result).toBe(false);
    }),
  returnFalseForValueWithoutType: (fn: TypeCheckFn) =>
    it('should return false if the value does not have a type-identifier', () => {
      // arrange
      const value = {};

      // act
      const result = fn(value);

      // assert
      expect(result).toBe(false);
    }),
  returnFalseForNonDefined: (fn: TypeCheckFn) =>
    it('should return false if the value is null or undefined', () => {
      // arrange, act, assert
      expect(fn(null)).toBe(false);
      expect(fn(undefined)).toBe(false);
    }),
};

export const FnFactorySpecs = {
  returnPassedInFnWithTypeSymbol: (fn: FnFactory, type: string) =>
    it(`should return the passed-in function with the Type symbol set to "${type}"`, () => {
      // arrange
      const input = () => {};

      // act
      const valueFn = fn(input);

      // assert
      expect(valueFn[Type]).toBe(type);
    }),
};

export const AttachedPropertySpecs = {
  retrieveImplementationFromAttachedProperty: (
    mutationFn: MutationFn,
    attachedProperty: string,
    returnValue: any,
    ...expectedArgs: any[]
  ) =>
    it('should take its probability implementation from attached properties', () => {
      // arrange
      const buildable = createBuildable(null);
      const spy = jasmine.createSpy('strategy').and.returnValue(returnValue);
      buildable.attachedProperties[attachedProperty] = spy;

      // act
      mutationFn(buildable);

      // assert
      expect(spy).toHaveBeenCalledTimes(1);
      expectedArgs.forEach(arg => {
        expect(spy).toHaveBeenCalledWith(arg);
      });
    }),
};

export const PropertyFnEndToEndSpecs = {
  cloneInputToAvoidSideEffectsWithQuantity: (
    mdlFactory: Func<[], { buildable: AnyObject; item: AnyObject }>,
  ) =>
    it('should clone the given input array to avoid errors with quantity', () => {
      // arrange
      const { buildable, item } = mdlFactory();

      /*
      the oneOf method should clone the items before choosing
      one in order to avoid side-effects on buildables within
      the targeted array for other oneOfs generated by quantity(n).

      This ensure that the other oneOfs do not choose already
      fix/built items, that would be dynamic/buildable otherwise.
    */
      const mdl = use(buildable, quantity(2));

      // act
      const items = build(mdl);

      // assert
      expect(items[0]).toEqual(item);
      expect(items[0]).not.toBe(item);
      expect(items[1]).toEqual(item);
      expect(items[1]).not.toBe(item);
    }),
};
